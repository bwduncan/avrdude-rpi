#!/usr/bin/python3

import sys
import os
import time
import fcntl
import RPi.GPIO as GPIO

DTR = 'TIOCM_DTR'
PIN = 7
PULSE_TIME = 0.32

def reset():
    GPIO.setup(PIN, GPIO.OUT)
    GPIO.output(PIN, GPIO.HIGH)
    time.sleep(PULSE_TIME)
    GPIO.output(PIN, GPIO.LOW)

def process():
    start = time.time()
    while True:
        try:
            duration = time.time() - start
            text = sys.stdin.readline().strip()
            if text is None: # == "":  # FIXME strip will never return None
                text = sys.stdin.readline().strip()
            if DTR in text:
                reset()
                return  # FIXME this will close stdin at exit and caused Broken Pipe errors. We should continue to act as a filter.
            elif duration > 5000: # FIXME arbitrary constant. 5000 seconds (1h23m) is a long time. where did it come from?
                return
        except Exception as e:
            if hasattr(e, 'errno'):  # FIXME ignoring EAGAIN is a side-effect of using non-blocking IO, but readline hides this from us and returns '' if there is no data. Don't use non-blocking IO.
                if e.errno != 11: # Ignore resource unavailable
                    raise
            else:
                raise
def main():
    fd = sys.stdin.fileno()
    fl = fcntl.fcntl(fd, fcntl.F_GETFL)
    fcntl.fcntl(fd, fcntl.F_SETFL, fl | os.O_NONBLOCK)

    GPIO.setwarnings(False)  # FIXME why disable warnings? This seems unwise!
    GPIO.setmode(GPIO.BOARD)
    process()
    print("avrdude-original: Using autoreset DTR on GPIO Pin", PIN)
    GPIO.cleanup()

if __name__ == '__main__':
    main()
